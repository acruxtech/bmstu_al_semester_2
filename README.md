# bmstu_al_semester_2

Репозиторий для практических, лабораторных работ и РК по АЯ 2 семестр (2025 год)
Отдельные задания расположены в соответсвующих ветках.

***Список веток:***
1. lab1
2. lab2
3. lab3
4. lab4
5. lab5
6. lab6
7. lab7
8. lab8
9. hw1 - ДЗ №1

# Лабораторная работа №7 (умные указатели)

## Задание №1

Реализовать шаблон для задания «умного» указателя по аналогии шаблона std::unique_ptr. 
В шаблоне предусмотреть конструктор, который получает «сырой» указатель, деструктор, конструкторы копирования 
и перемещения (что-то удаляется), операторы присваивания с копированием и перемещением (что-то удаляется), метод get, возвращающий «сырой указатель», выполнить перегрузку операций * и ->, запретить создание копий объектов, реализовать перемещение. Возможные заголовки методов шаблона кроме конструкторов и операторов присваивания копирования и перемещения приведены ниже:
```
template<class T>
class MyUnique
{
    T * p=nullptr;
public:
    MyUnique(T *p);
    ~MyUnique();
    T * get() const;
    T & operator*();
    T * operator->();
};
```
Для создания объекта типа MyUnique разработать глобальную шаблонную функцию Make_MyUnique с  переменным числом параметров, которая получает параметры как у конструктора объекта, на который указывает указатель. Теория по таким функциям приведена ниже в подразделе Шаблоны с переменным числом параметров (variadic template).
В функции main продемонстрировать все заданные возможности, в том числе, создать указатель  на объект своего класса, имеющего конструктор с параметрами (например, класса MyPoint – точка на плоскости) c помощью функции Make_MyUnique, получающей параметры как конструктора своего класса (MyPoint).

## Задание №2

Аналогично разработать шаблон для задания «умного» указателя по аналогии шаблона std::shared_ptr, который отличается от шаблона части 1  тем, что разрешает копирование. Назвать его можно MyShared. Разработать также глобальную шаблонную функцию Make_MyShared, которая получает параметры как у конструктора объекта, на который указывает указатель. Продемонстрировать все возможности в функции main по аналогии с частью 1.